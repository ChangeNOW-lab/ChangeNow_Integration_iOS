//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }

  /// This `R.image` struct is generated, and contains static references to 176 images.
  struct image {
    /// Image `BackIcon`.
    static let backIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "BackIcon")
    /// Image `CaptureZone`.
    static let captureZone = Rswift.ImageResource(bundle: R.hostingBundle, name: "CaptureZone")
    /// Image `CircleActive`.
    static let circleActive = Rswift.ImageResource(bundle: R.hostingBundle, name: "CircleActive")
    /// Image `CircleInactive`.
    static let circleInactive = Rswift.ImageResource(bundle: R.hostingBundle, name: "CircleInactive")
    /// Image `CloseLight`.
    static let closeLight = Rswift.ImageResource(bundle: R.hostingBundle, name: "CloseLight")
    /// Image `Close`.
    static let close = Rswift.ImageResource(bundle: R.hostingBundle, name: "Close")
    /// Image `CurrencyPlaceholder`.
    static let currencyPlaceholder = Rswift.ImageResource(bundle: R.hostingBundle, name: "CurrencyPlaceholder")
    /// Image `Deeplink`.
    static let deeplink = Rswift.ImageResource(bundle: R.hostingBundle, name: "Deeplink")
    /// Image `DepositIcon`.
    static let depositIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "DepositIcon")
    /// Image `ExchangingIcon`.
    static let exchangingIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "ExchangingIcon")
    /// Image `ExpandArrow`.
    static let expandArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "ExpandArrow")
    /// Image `FinishedIcon`.
    static let finishedIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "FinishedIcon")
    /// Image `FinishedMoreIcon`.
    static let finishedMoreIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "FinishedMoreIcon")
    /// Image `FlashDisabled`.
    static let flashDisabled = Rswift.ImageResource(bundle: R.hostingBundle, name: "FlashDisabled")
    /// Image `FlashEnabled`.
    static let flashEnabled = Rswift.ImageResource(bundle: R.hostingBundle, name: "FlashEnabled")
    /// Image `GrowArrow`.
    static let growArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "GrowArrow")
    /// Image `GuardaWallet`.
    static let guardaWallet = Rswift.ImageResource(bundle: R.hostingBundle, name: "GuardaWallet")
    /// Image `Heart`.
    static let heart = Rswift.ImageResource(bundle: R.hostingBundle, name: "Heart")
    /// Image `HideArrow`.
    static let hideArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "HideArrow")
    /// Image `Like`.
    static let like = Rswift.ImageResource(bundle: R.hostingBundle, name: "Like")
    /// Image `Mail`.
    static let mail = Rswift.ImageResource(bundle: R.hostingBundle, name: "Mail")
    /// Image `MiniLogo`.
    static let miniLogo = Rswift.ImageResource(bundle: R.hostingBundle, name: "MiniLogo")
    /// Image `NextArrow`.
    static let nextArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "NextArrow")
    /// Image `QrDark`.
    static let qrDark = Rswift.ImageResource(bundle: R.hostingBundle, name: "QrDark")
    /// Image `RefundedIcon`.
    static let refundedIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "RefundedIcon")
    /// Image `SearchClear`.
    static let searchClear = Rswift.ImageResource(bundle: R.hostingBundle, name: "SearchClear")
    /// Image `SearchIcon`.
    static let searchIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "SearchIcon")
    /// Image `ShareDark`.
    static let shareDark = Rswift.ImageResource(bundle: R.hostingBundle, name: "ShareDark")
    /// Image `Star`.
    static let star = Rswift.ImageResource(bundle: R.hostingBundle, name: "Star")
    /// Image `SwitchArrows`.
    static let switchArrows = Rswift.ImageResource(bundle: R.hostingBundle, name: "SwitchArrows")
    /// Image `TrustWallet`.
    static let trustWallet = Rswift.ImageResource(bundle: R.hostingBundle, name: "TrustWallet")
    /// Image `Underline`.
    static let underline = Rswift.ImageResource(bundle: R.hostingBundle, name: "Underline")
    /// Image `VisaAndMastercard`.
    static let visaAndMastercard = Rswift.ImageResource(bundle: R.hostingBundle, name: "VisaAndMastercard")
    /// Image `ada`.
    static let ada = Rswift.ImageResource(bundle: R.hostingBundle, name: "ada")
    /// Image `adx`.
    static let adx = Rswift.ImageResource(bundle: R.hostingBundle, name: "adx")
    /// Image `ae`.
    static let ae = Rswift.ImageResource(bundle: R.hostingBundle, name: "ae")
    /// Image `agi`.
    static let agi = Rswift.ImageResource(bundle: R.hostingBundle, name: "agi")
    /// Image `aion`.
    static let aion = Rswift.ImageResource(bundle: R.hostingBundle, name: "aion")
    /// Image `amb`.
    static let amb = Rswift.ImageResource(bundle: R.hostingBundle, name: "amb")
    /// Image `ardr`.
    static let ardr = Rswift.ImageResource(bundle: R.hostingBundle, name: "ardr")
    /// Image `ark`.
    static let ark = Rswift.ImageResource(bundle: R.hostingBundle, name: "ark")
    /// Image `arn`.
    static let arn = Rswift.ImageResource(bundle: R.hostingBundle, name: "arn")
    /// Image `ast`.
    static let ast = Rswift.ImageResource(bundle: R.hostingBundle, name: "ast")
    /// Image `atom`.
    static let atom = Rswift.ImageResource(bundle: R.hostingBundle, name: "atom")
    /// Image `band`.
    static let band = Rswift.ImageResource(bundle: R.hostingBundle, name: "band")
    /// Image `bat`.
    static let bat = Rswift.ImageResource(bundle: R.hostingBundle, name: "bat")
    /// Image `bcd`.
    static let bcd = Rswift.ImageResource(bundle: R.hostingBundle, name: "bcd")
    /// Image `bch`.
    static let bch = Rswift.ImageResource(bundle: R.hostingBundle, name: "bch")
    /// Image `beam`.
    static let beam = Rswift.ImageResource(bundle: R.hostingBundle, name: "beam")
    /// Image `blz`.
    static let blz = Rswift.ImageResource(bundle: R.hostingBundle, name: "blz")
    /// Image `bnb`.
    static let bnb = Rswift.ImageResource(bundle: R.hostingBundle, name: "bnb")
    /// Image `bnbmainnet`.
    static let bnbmainnet = Rswift.ImageResource(bundle: R.hostingBundle, name: "bnbmainnet")
    /// Image `bnt`.
    static let bnt = Rswift.ImageResource(bundle: R.hostingBundle, name: "bnt")
    /// Image `bqx`.
    static let bqx = Rswift.ImageResource(bundle: R.hostingBundle, name: "bqx")
    /// Image `brd`.
    static let brd = Rswift.ImageResource(bundle: R.hostingBundle, name: "brd")
    /// Image `bsv`.
    static let bsv = Rswift.ImageResource(bundle: R.hostingBundle, name: "bsv")
    /// Image `btc`.
    static let btc = Rswift.ImageResource(bundle: R.hostingBundle, name: "btc")
    /// Image `btg`.
    static let btg = Rswift.ImageResource(bundle: R.hostingBundle, name: "btg")
    /// Image `btt`.
    static let btt = Rswift.ImageResource(bundle: R.hostingBundle, name: "btt")
    /// Image `busd`.
    static let busd = Rswift.ImageResource(bundle: R.hostingBundle, name: "busd")
    /// Image `celr`.
    static let celr = Rswift.ImageResource(bundle: R.hostingBundle, name: "celr")
    /// Image `clo`.
    static let clo = Rswift.ImageResource(bundle: R.hostingBundle, name: "clo")
    /// Image `cmt`.
    static let cmt = Rswift.ImageResource(bundle: R.hostingBundle, name: "cmt")
    /// Image `cnd`.
    static let cnd = Rswift.ImageResource(bundle: R.hostingBundle, name: "cnd")
    /// Image `copy`.
    static let copy = Rswift.ImageResource(bundle: R.hostingBundle, name: "copy")
    /// Image `cro`.
    static let cro = Rswift.ImageResource(bundle: R.hostingBundle, name: "cro")
    /// Image `cvc`.
    static let cvc = Rswift.ImageResource(bundle: R.hostingBundle, name: "cvc")
    /// Image `dai`.
    static let dai = Rswift.ImageResource(bundle: R.hostingBundle, name: "dai")
    /// Image `dash`.
    static let dash = Rswift.ImageResource(bundle: R.hostingBundle, name: "dash")
    /// Image `dcr`.
    static let dcr = Rswift.ImageResource(bundle: R.hostingBundle, name: "dcr")
    /// Image `dgb`.
    static let dgb = Rswift.ImageResource(bundle: R.hostingBundle, name: "dgb")
    /// Image `dgd`.
    static let dgd = Rswift.ImageResource(bundle: R.hostingBundle, name: "dgd")
    /// Image `dlt`.
    static let dlt = Rswift.ImageResource(bundle: R.hostingBundle, name: "dlt")
    /// Image `dnt`.
    static let dnt = Rswift.ImageResource(bundle: R.hostingBundle, name: "dnt")
    /// Image `dock`.
    static let dock = Rswift.ImageResource(bundle: R.hostingBundle, name: "dock")
    /// Image `doge`.
    static let doge = Rswift.ImageResource(bundle: R.hostingBundle, name: "doge")
    /// Image `elf`.
    static let elf = Rswift.ImageResource(bundle: R.hostingBundle, name: "elf")
    /// Image `eng`.
    static let eng = Rswift.ImageResource(bundle: R.hostingBundle, name: "eng")
    /// Image `enj`.
    static let enj = Rswift.ImageResource(bundle: R.hostingBundle, name: "enj")
    /// Image `eos`.
    static let eos = Rswift.ImageResource(bundle: R.hostingBundle, name: "eos")
    /// Image `etc`.
    static let etc = Rswift.ImageResource(bundle: R.hostingBundle, name: "etc")
    /// Image `eth`.
    static let eth = Rswift.ImageResource(bundle: R.hostingBundle, name: "eth")
    /// Image `evx`.
    static let evx = Rswift.ImageResource(bundle: R.hostingBundle, name: "evx")
    /// Image `fet`.
    static let fet = Rswift.ImageResource(bundle: R.hostingBundle, name: "fet")
    /// Image `fun`.
    static let fun = Rswift.ImageResource(bundle: R.hostingBundle, name: "fun")
    /// Image `gas`.
    static let gas = Rswift.ImageResource(bundle: R.hostingBundle, name: "gas")
    /// Image `gnt`.
    static let gnt = Rswift.ImageResource(bundle: R.hostingBundle, name: "gnt")
    /// Image `go`.
    static let go = Rswift.ImageResource(bundle: R.hostingBundle, name: "go")
    /// Image `grs`.
    static let grs = Rswift.ImageResource(bundle: R.hostingBundle, name: "grs")
    /// Image `gto`.
    static let gto = Rswift.ImageResource(bundle: R.hostingBundle, name: "gto")
    /// Image `hbar`.
    static let hbar = Rswift.ImageResource(bundle: R.hostingBundle, name: "hbar")
    /// Image `hc`.
    static let hc = Rswift.ImageResource(bundle: R.hostingBundle, name: "hc")
    /// Image `hot`.
    static let hot = Rswift.ImageResource(bundle: R.hostingBundle, name: "hot")
    /// Image `ht`.
    static let ht = Rswift.ImageResource(bundle: R.hostingBundle, name: "ht")
    /// Image `husd`.
    static let husd = Rswift.ImageResource(bundle: R.hostingBundle, name: "husd")
    /// Image `icx`.
    static let icx = Rswift.ImageResource(bundle: R.hostingBundle, name: "icx")
    /// Image `iost`.
    static let iost = Rswift.ImageResource(bundle: R.hostingBundle, name: "iost")
    /// Image `iota`.
    static let iota = Rswift.ImageResource(bundle: R.hostingBundle, name: "iota")
    /// Image `kan`.
    static let kan = Rswift.ImageResource(bundle: R.hostingBundle, name: "kan")
    /// Image `kmd`.
    static let kmd = Rswift.ImageResource(bundle: R.hostingBundle, name: "kmd")
    /// Image `knc`.
    static let knc = Rswift.ImageResource(bundle: R.hostingBundle, name: "knc")
    /// Image `lend`.
    static let lend = Rswift.ImageResource(bundle: R.hostingBundle, name: "lend")
    /// Image `loom`.
    static let loom = Rswift.ImageResource(bundle: R.hostingBundle, name: "loom")
    /// Image `lrc`.
    static let lrc = Rswift.ImageResource(bundle: R.hostingBundle, name: "lrc")
    /// Image `lsk`.
    static let lsk = Rswift.ImageResource(bundle: R.hostingBundle, name: "lsk")
    /// Image `ltc`.
    static let ltc = Rswift.ImageResource(bundle: R.hostingBundle, name: "ltc")
    /// Image `ltx`.
    static let ltx = Rswift.ImageResource(bundle: R.hostingBundle, name: "ltx")
    /// Image `lun`.
    static let lun = Rswift.ImageResource(bundle: R.hostingBundle, name: "lun")
    /// Image `mana`.
    static let mana = Rswift.ImageResource(bundle: R.hostingBundle, name: "mana")
    /// Image `matic`.
    static let matic = Rswift.ImageResource(bundle: R.hostingBundle, name: "matic")
    /// Image `mco`.
    static let mco = Rswift.ImageResource(bundle: R.hostingBundle, name: "mco")
    /// Image `mda`.
    static let mda = Rswift.ImageResource(bundle: R.hostingBundle, name: "mda")
    /// Image `mtl`.
    static let mtl = Rswift.ImageResource(bundle: R.hostingBundle, name: "mtl")
    /// Image `nano`.
    static let nano = Rswift.ImageResource(bundle: R.hostingBundle, name: "nano")
    /// Image `neo`.
    static let neo = Rswift.ImageResource(bundle: R.hostingBundle, name: "neo")
    /// Image `nexo`.
    static let nexo = Rswift.ImageResource(bundle: R.hostingBundle, name: "nexo")
    /// Image `node`.
    static let node = Rswift.ImageResource(bundle: R.hostingBundle, name: "node")
    /// Image `npxs`.
    static let npxs = Rswift.ImageResource(bundle: R.hostingBundle, name: "npxs")
    /// Image `omg`.
    static let omg = Rswift.ImageResource(bundle: R.hostingBundle, name: "omg")
    /// Image `ong`.
    static let ong = Rswift.ImageResource(bundle: R.hostingBundle, name: "ong")
    /// Image `ont`.
    static let ont = Rswift.ImageResource(bundle: R.hostingBundle, name: "ont")
    /// Image `pax`.
    static let pax = Rswift.ImageResource(bundle: R.hostingBundle, name: "pax")
    /// Image `pay`.
    static let pay = Rswift.ImageResource(bundle: R.hostingBundle, name: "pay")
    /// Image `perl`.
    static let perl = Rswift.ImageResource(bundle: R.hostingBundle, name: "perl")
    /// Image `pivx`.
    static let pivx = Rswift.ImageResource(bundle: R.hostingBundle, name: "pivx")
    /// Image `poe`.
    static let poe = Rswift.ImageResource(bundle: R.hostingBundle, name: "poe")
    /// Image `poly`.
    static let poly = Rswift.ImageResource(bundle: R.hostingBundle, name: "poly")
    /// Image `powr`.
    static let powr = Rswift.ImageResource(bundle: R.hostingBundle, name: "powr")
    /// Image `ppt`.
    static let ppt = Rswift.ImageResource(bundle: R.hostingBundle, name: "ppt")
    /// Image `qrLogo`.
    static let qrLogo = Rswift.ImageResource(bundle: R.hostingBundle, name: "qrLogo")
    /// Image `qtum`.
    static let qtum = Rswift.ImageResource(bundle: R.hostingBundle, name: "qtum")
    /// Image `rcn`.
    static let rcn = Rswift.ImageResource(bundle: R.hostingBundle, name: "rcn")
    /// Image `rdn`.
    static let rdn = Rswift.ImageResource(bundle: R.hostingBundle, name: "rdn")
    /// Image `ren`.
    static let ren = Rswift.ImageResource(bundle: R.hostingBundle, name: "ren")
    /// Image `rep`.
    static let rep = Rswift.ImageResource(bundle: R.hostingBundle, name: "rep")
    /// Image `rlc`.
    static let rlc = Rswift.ImageResource(bundle: R.hostingBundle, name: "rlc")
    /// Image `rvn`.
    static let rvn = Rswift.ImageResource(bundle: R.hostingBundle, name: "rvn")
    /// Image `sc`.
    static let sc = Rswift.ImageResource(bundle: R.hostingBundle, name: "sc")
    /// Image `sngls`.
    static let sngls = Rswift.ImageResource(bundle: R.hostingBundle, name: "sngls")
    /// Image `snm`.
    static let snm = Rswift.ImageResource(bundle: R.hostingBundle, name: "snm")
    /// Image `snt`.
    static let snt = Rswift.ImageResource(bundle: R.hostingBundle, name: "snt")
    /// Image `soc`.
    static let soc = Rswift.ImageResource(bundle: R.hostingBundle, name: "soc")
    /// Image `srn`.
    static let srn = Rswift.ImageResource(bundle: R.hostingBundle, name: "srn")
    /// Image `steem`.
    static let steem = Rswift.ImageResource(bundle: R.hostingBundle, name: "steem")
    /// Image `stmx`.
    static let stmx = Rswift.ImageResource(bundle: R.hostingBundle, name: "stmx")
    /// Image `storj`.
    static let storj = Rswift.ImageResource(bundle: R.hostingBundle, name: "storj")
    /// Image `storm`.
    static let storm = Rswift.ImageResource(bundle: R.hostingBundle, name: "storm")
    /// Image `strat`.
    static let strat = Rswift.ImageResource(bundle: R.hostingBundle, name: "strat")
    /// Image `sys`.
    static let sys = Rswift.ImageResource(bundle: R.hostingBundle, name: "sys")
    /// Image `tnt`.
    static let tnt = Rswift.ImageResource(bundle: R.hostingBundle, name: "tnt")
    /// Image `trx`.
    static let trx = Rswift.ImageResource(bundle: R.hostingBundle, name: "trx")
    /// Image `tusd`.
    static let tusd = Rswift.ImageResource(bundle: R.hostingBundle, name: "tusd")
    /// Image `usd`.
    static let usd = Rswift.ImageResource(bundle: R.hostingBundle, name: "usd")
    /// Image `usdt`.
    static let usdt = Rswift.ImageResource(bundle: R.hostingBundle, name: "usdt")
    /// Image `usdterc20`.
    static let usdterc20 = Rswift.ImageResource(bundle: R.hostingBundle, name: "usdterc20")
    /// Image `usdttrc20`.
    static let usdttrc20 = Rswift.ImageResource(bundle: R.hostingBundle, name: "usdttrc20")
    /// Image `utk`.
    static let utk = Rswift.ImageResource(bundle: R.hostingBundle, name: "utk")
    /// Image `vet`.
    static let vet = Rswift.ImageResource(bundle: R.hostingBundle, name: "vet")
    /// Image `vib`.
    static let vib = Rswift.ImageResource(bundle: R.hostingBundle, name: "vib")
    /// Image `vibe`.
    static let vibe = Rswift.ImageResource(bundle: R.hostingBundle, name: "vibe")
    /// Image `wabi`.
    static let wabi = Rswift.ImageResource(bundle: R.hostingBundle, name: "wabi")
    /// Image `waves`.
    static let waves = Rswift.ImageResource(bundle: R.hostingBundle, name: "waves")
    /// Image `wtc`.
    static let wtc = Rswift.ImageResource(bundle: R.hostingBundle, name: "wtc")
    /// Image `xaut`.
    static let xaut = Rswift.ImageResource(bundle: R.hostingBundle, name: "xaut")
    /// Image `xchf`.
    static let xchf = Rswift.ImageResource(bundle: R.hostingBundle, name: "xchf")
    /// Image `xem`.
    static let xem = Rswift.ImageResource(bundle: R.hostingBundle, name: "xem")
    /// Image `xlm`.
    static let xlm = Rswift.ImageResource(bundle: R.hostingBundle, name: "xlm")
    /// Image `xmr`.
    static let xmr = Rswift.ImageResource(bundle: R.hostingBundle, name: "xmr")
    /// Image `xrp`.
    static let xrp = Rswift.ImageResource(bundle: R.hostingBundle, name: "xrp")
    /// Image `xtz`.
    static let xtz = Rswift.ImageResource(bundle: R.hostingBundle, name: "xtz")
    /// Image `xvg`.
    static let xvg = Rswift.ImageResource(bundle: R.hostingBundle, name: "xvg")
    /// Image `xzc`.
    static let xzc = Rswift.ImageResource(bundle: R.hostingBundle, name: "xzc")
    /// Image `zec`.
    static let zec = Rswift.ImageResource(bundle: R.hostingBundle, name: "zec")
    /// Image `zen`.
    static let zen = Rswift.ImageResource(bundle: R.hostingBundle, name: "zen")
    /// Image `zil`.
    static let zil = Rswift.ImageResource(bundle: R.hostingBundle, name: "zil")
    /// Image `zrx`.
    static let zrx = Rswift.ImageResource(bundle: R.hostingBundle, name: "zrx")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "BackIcon", bundle: ..., traitCollection: ...)`
    static func backIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "CaptureZone", bundle: ..., traitCollection: ...)`
    static func captureZone(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.captureZone, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "CircleActive", bundle: ..., traitCollection: ...)`
    static func circleActive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.circleActive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "CircleInactive", bundle: ..., traitCollection: ...)`
    static func circleInactive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.circleInactive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Close", bundle: ..., traitCollection: ...)`
    static func close(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.close, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "CloseLight", bundle: ..., traitCollection: ...)`
    static func closeLight(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.closeLight, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "CurrencyPlaceholder", bundle: ..., traitCollection: ...)`
    static func currencyPlaceholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.currencyPlaceholder, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Deeplink", bundle: ..., traitCollection: ...)`
    static func deeplink(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.deeplink, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "DepositIcon", bundle: ..., traitCollection: ...)`
    static func depositIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.depositIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ExchangingIcon", bundle: ..., traitCollection: ...)`
    static func exchangingIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.exchangingIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ExpandArrow", bundle: ..., traitCollection: ...)`
    static func expandArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.expandArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "FinishedIcon", bundle: ..., traitCollection: ...)`
    static func finishedIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.finishedIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "FinishedMoreIcon", bundle: ..., traitCollection: ...)`
    static func finishedMoreIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.finishedMoreIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "FlashDisabled", bundle: ..., traitCollection: ...)`
    static func flashDisabled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.flashDisabled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "FlashEnabled", bundle: ..., traitCollection: ...)`
    static func flashEnabled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.flashEnabled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "GrowArrow", bundle: ..., traitCollection: ...)`
    static func growArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.growArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "GuardaWallet", bundle: ..., traitCollection: ...)`
    static func guardaWallet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.guardaWallet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Heart", bundle: ..., traitCollection: ...)`
    static func heart(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.heart, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "HideArrow", bundle: ..., traitCollection: ...)`
    static func hideArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.hideArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Like", bundle: ..., traitCollection: ...)`
    static func like(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.like, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Mail", bundle: ..., traitCollection: ...)`
    static func mail(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mail, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "MiniLogo", bundle: ..., traitCollection: ...)`
    static func miniLogo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.miniLogo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "NextArrow", bundle: ..., traitCollection: ...)`
    static func nextArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.nextArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "QrDark", bundle: ..., traitCollection: ...)`
    static func qrDark(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.qrDark, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "RefundedIcon", bundle: ..., traitCollection: ...)`
    static func refundedIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.refundedIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "SearchClear", bundle: ..., traitCollection: ...)`
    static func searchClear(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.searchClear, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "SearchIcon", bundle: ..., traitCollection: ...)`
    static func searchIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.searchIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ShareDark", bundle: ..., traitCollection: ...)`
    static func shareDark(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.shareDark, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Star", bundle: ..., traitCollection: ...)`
    static func star(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.star, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "SwitchArrows", bundle: ..., traitCollection: ...)`
    static func switchArrows(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.switchArrows, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TrustWallet", bundle: ..., traitCollection: ...)`
    static func trustWallet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trustWallet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Underline", bundle: ..., traitCollection: ...)`
    static func underline(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.underline, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "VisaAndMastercard", bundle: ..., traitCollection: ...)`
    static func visaAndMastercard(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.visaAndMastercard, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ada", bundle: ..., traitCollection: ...)`
    static func ada(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ada, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "adx", bundle: ..., traitCollection: ...)`
    static func adx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.adx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ae", bundle: ..., traitCollection: ...)`
    static func ae(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ae, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "agi", bundle: ..., traitCollection: ...)`
    static func agi(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.agi, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "aion", bundle: ..., traitCollection: ...)`
    static func aion(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.aion, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "amb", bundle: ..., traitCollection: ...)`
    static func amb(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.amb, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ardr", bundle: ..., traitCollection: ...)`
    static func ardr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ardr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ark", bundle: ..., traitCollection: ...)`
    static func ark(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ark, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "arn", bundle: ..., traitCollection: ...)`
    static func arn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.arn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ast", bundle: ..., traitCollection: ...)`
    static func ast(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ast, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "atom", bundle: ..., traitCollection: ...)`
    static func atom(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.atom, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "band", bundle: ..., traitCollection: ...)`
    static func band(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.band, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bat", bundle: ..., traitCollection: ...)`
    static func bat(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bat, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bcd", bundle: ..., traitCollection: ...)`
    static func bcd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bcd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bch", bundle: ..., traitCollection: ...)`
    static func bch(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bch, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "beam", bundle: ..., traitCollection: ...)`
    static func beam(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.beam, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "blz", bundle: ..., traitCollection: ...)`
    static func blz(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.blz, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bnb", bundle: ..., traitCollection: ...)`
    static func bnb(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bnb, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bnbmainnet", bundle: ..., traitCollection: ...)`
    static func bnbmainnet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bnbmainnet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bnt", bundle: ..., traitCollection: ...)`
    static func bnt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bnt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bqx", bundle: ..., traitCollection: ...)`
    static func bqx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bqx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "brd", bundle: ..., traitCollection: ...)`
    static func brd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.brd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bsv", bundle: ..., traitCollection: ...)`
    static func bsv(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bsv, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "btc", bundle: ..., traitCollection: ...)`
    static func btc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.btc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "btg", bundle: ..., traitCollection: ...)`
    static func btg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.btg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "btt", bundle: ..., traitCollection: ...)`
    static func btt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.btt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "busd", bundle: ..., traitCollection: ...)`
    static func busd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.busd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "celr", bundle: ..., traitCollection: ...)`
    static func celr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.celr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "clo", bundle: ..., traitCollection: ...)`
    static func clo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.clo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "cmt", bundle: ..., traitCollection: ...)`
    static func cmt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.cmt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "cnd", bundle: ..., traitCollection: ...)`
    static func cnd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.cnd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "copy", bundle: ..., traitCollection: ...)`
    static func copy(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.copy, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "cro", bundle: ..., traitCollection: ...)`
    static func cro(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.cro, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "cvc", bundle: ..., traitCollection: ...)`
    static func cvc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.cvc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dai", bundle: ..., traitCollection: ...)`
    static func dai(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dai, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dash", bundle: ..., traitCollection: ...)`
    static func dash(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dash, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dcr", bundle: ..., traitCollection: ...)`
    static func dcr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dcr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dgb", bundle: ..., traitCollection: ...)`
    static func dgb(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dgb, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dgd", bundle: ..., traitCollection: ...)`
    static func dgd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dgd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dlt", bundle: ..., traitCollection: ...)`
    static func dlt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dlt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dnt", bundle: ..., traitCollection: ...)`
    static func dnt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dnt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "dock", bundle: ..., traitCollection: ...)`
    static func dock(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.dock, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "doge", bundle: ..., traitCollection: ...)`
    static func doge(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.doge, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "elf", bundle: ..., traitCollection: ...)`
    static func elf(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.elf, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "eng", bundle: ..., traitCollection: ...)`
    static func eng(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.eng, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "enj", bundle: ..., traitCollection: ...)`
    static func enj(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.enj, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "eos", bundle: ..., traitCollection: ...)`
    static func eos(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.eos, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "etc", bundle: ..., traitCollection: ...)`
    static func etc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.etc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "eth", bundle: ..., traitCollection: ...)`
    static func eth(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.eth, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "evx", bundle: ..., traitCollection: ...)`
    static func evx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.evx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "fet", bundle: ..., traitCollection: ...)`
    static func fet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.fet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "fun", bundle: ..., traitCollection: ...)`
    static func fun(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.fun, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "gas", bundle: ..., traitCollection: ...)`
    static func gas(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.gas, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "gnt", bundle: ..., traitCollection: ...)`
    static func gnt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.gnt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "go", bundle: ..., traitCollection: ...)`
    static func go(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.go, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "grs", bundle: ..., traitCollection: ...)`
    static func grs(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.grs, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "gto", bundle: ..., traitCollection: ...)`
    static func gto(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.gto, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "hbar", bundle: ..., traitCollection: ...)`
    static func hbar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.hbar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "hc", bundle: ..., traitCollection: ...)`
    static func hc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.hc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "hot", bundle: ..., traitCollection: ...)`
    static func hot(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.hot, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ht", bundle: ..., traitCollection: ...)`
    static func ht(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ht, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "husd", bundle: ..., traitCollection: ...)`
    static func husd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.husd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icx", bundle: ..., traitCollection: ...)`
    static func icx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iost", bundle: ..., traitCollection: ...)`
    static func iost(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iost, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iota", bundle: ..., traitCollection: ...)`
    static func iota(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iota, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "kan", bundle: ..., traitCollection: ...)`
    static func kan(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.kan, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "kmd", bundle: ..., traitCollection: ...)`
    static func kmd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.kmd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "knc", bundle: ..., traitCollection: ...)`
    static func knc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.knc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "lend", bundle: ..., traitCollection: ...)`
    static func lend(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.lend, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "loom", bundle: ..., traitCollection: ...)`
    static func loom(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.loom, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "lrc", bundle: ..., traitCollection: ...)`
    static func lrc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.lrc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "lsk", bundle: ..., traitCollection: ...)`
    static func lsk(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.lsk, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ltc", bundle: ..., traitCollection: ...)`
    static func ltc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ltc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ltx", bundle: ..., traitCollection: ...)`
    static func ltx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ltx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "lun", bundle: ..., traitCollection: ...)`
    static func lun(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.lun, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mana", bundle: ..., traitCollection: ...)`
    static func mana(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mana, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "matic", bundle: ..., traitCollection: ...)`
    static func matic(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.matic, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mco", bundle: ..., traitCollection: ...)`
    static func mco(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mco, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mda", bundle: ..., traitCollection: ...)`
    static func mda(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mda, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mtl", bundle: ..., traitCollection: ...)`
    static func mtl(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mtl, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "nano", bundle: ..., traitCollection: ...)`
    static func nano(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.nano, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "neo", bundle: ..., traitCollection: ...)`
    static func neo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.neo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "nexo", bundle: ..., traitCollection: ...)`
    static func nexo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.nexo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "node", bundle: ..., traitCollection: ...)`
    static func node(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.node, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "npxs", bundle: ..., traitCollection: ...)`
    static func npxs(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.npxs, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "omg", bundle: ..., traitCollection: ...)`
    static func omg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.omg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ong", bundle: ..., traitCollection: ...)`
    static func ong(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ong, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ont", bundle: ..., traitCollection: ...)`
    static func ont(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ont, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pax", bundle: ..., traitCollection: ...)`
    static func pax(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pax, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pay", bundle: ..., traitCollection: ...)`
    static func pay(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pay, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "perl", bundle: ..., traitCollection: ...)`
    static func perl(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.perl, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pivx", bundle: ..., traitCollection: ...)`
    static func pivx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pivx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "poe", bundle: ..., traitCollection: ...)`
    static func poe(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.poe, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "poly", bundle: ..., traitCollection: ...)`
    static func poly(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.poly, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "powr", bundle: ..., traitCollection: ...)`
    static func powr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.powr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ppt", bundle: ..., traitCollection: ...)`
    static func ppt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ppt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "qrLogo", bundle: ..., traitCollection: ...)`
    static func qrLogo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.qrLogo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "qtum", bundle: ..., traitCollection: ...)`
    static func qtum(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.qtum, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "rcn", bundle: ..., traitCollection: ...)`
    static func rcn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.rcn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "rdn", bundle: ..., traitCollection: ...)`
    static func rdn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.rdn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ren", bundle: ..., traitCollection: ...)`
    static func ren(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ren, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "rep", bundle: ..., traitCollection: ...)`
    static func rep(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.rep, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "rlc", bundle: ..., traitCollection: ...)`
    static func rlc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.rlc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "rvn", bundle: ..., traitCollection: ...)`
    static func rvn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.rvn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sc", bundle: ..., traitCollection: ...)`
    static func sc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sngls", bundle: ..., traitCollection: ...)`
    static func sngls(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sngls, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "snm", bundle: ..., traitCollection: ...)`
    static func snm(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.snm, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "snt", bundle: ..., traitCollection: ...)`
    static func snt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.snt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "soc", bundle: ..., traitCollection: ...)`
    static func soc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.soc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "srn", bundle: ..., traitCollection: ...)`
    static func srn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.srn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "steem", bundle: ..., traitCollection: ...)`
    static func steem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.steem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "stmx", bundle: ..., traitCollection: ...)`
    static func stmx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.stmx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "storj", bundle: ..., traitCollection: ...)`
    static func storj(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.storj, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "storm", bundle: ..., traitCollection: ...)`
    static func storm(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.storm, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "strat", bundle: ..., traitCollection: ...)`
    static func strat(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.strat, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sys", bundle: ..., traitCollection: ...)`
    static func sys(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sys, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "tnt", bundle: ..., traitCollection: ...)`
    static func tnt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.tnt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "trx", bundle: ..., traitCollection: ...)`
    static func trx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trx, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "tusd", bundle: ..., traitCollection: ...)`
    static func tusd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.tusd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "usd", bundle: ..., traitCollection: ...)`
    static func usd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.usd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "usdt", bundle: ..., traitCollection: ...)`
    static func usdt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.usdt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "usdterc20", bundle: ..., traitCollection: ...)`
    static func usdterc20(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.usdterc20, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "usdttrc20", bundle: ..., traitCollection: ...)`
    static func usdttrc20(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.usdttrc20, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "utk", bundle: ..., traitCollection: ...)`
    static func utk(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.utk, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "vet", bundle: ..., traitCollection: ...)`
    static func vet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.vet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "vib", bundle: ..., traitCollection: ...)`
    static func vib(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.vib, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "vibe", bundle: ..., traitCollection: ...)`
    static func vibe(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.vibe, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "wabi", bundle: ..., traitCollection: ...)`
    static func wabi(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.wabi, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "waves", bundle: ..., traitCollection: ...)`
    static func waves(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.waves, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "wtc", bundle: ..., traitCollection: ...)`
    static func wtc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.wtc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xaut", bundle: ..., traitCollection: ...)`
    static func xaut(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xaut, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xchf", bundle: ..., traitCollection: ...)`
    static func xchf(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xchf, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xem", bundle: ..., traitCollection: ...)`
    static func xem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xlm", bundle: ..., traitCollection: ...)`
    static func xlm(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xlm, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xmr", bundle: ..., traitCollection: ...)`
    static func xmr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xmr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xrp", bundle: ..., traitCollection: ...)`
    static func xrp(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xrp, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xtz", bundle: ..., traitCollection: ...)`
    static func xtz(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xtz, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xvg", bundle: ..., traitCollection: ...)`
    static func xvg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xvg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "xzc", bundle: ..., traitCollection: ...)`
    static func xzc(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.xzc, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "zec", bundle: ..., traitCollection: ...)`
    static func zec(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.zec, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "zen", bundle: ..., traitCollection: ...)`
    static func zen(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.zen, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "zil", bundle: ..., traitCollection: ...)`
    static func zil(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.zil, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "zrx", bundle: ..., traitCollection: ...)`
    static func zrx(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.zrx, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 1 localization tables.
  struct string {
    /// This `R.string.localizable` struct is generated, and contains static references to 89 localization keys.
    struct localizable {
      /// en translation: %1$@ to %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionTitle = Rswift.StringResource(key: "Transaction.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: %@ (optional)
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExtraId = Rswift.StringResource(key: "Exchange.ExtraId", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: %@ Wallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let depositQRWallet = Rswift.StringResource(key: "DepositQR.Wallet", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: %@ coin is not supported by TrustWallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositTrustWalletNotSupported = Rswift.StringResource(key: "Transaction.Deposit.TrustWallet.NotSupported", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Add %@ Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeAddress = Rswift.StringResource(key: "Exchange.Address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Are you sure to start a new transaction?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStartNewAlert = Rswift.StringResource(key: "Transaction.StartNew.Alert", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Are you sure want to cancel this transaction and start a new one?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionCancelText = Rswift.StringResource(key: "Transaction.Cancel.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Awaiting deposit
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusDeposit = Rswift.StringResource(key: "Transaction.Status.Deposit", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Can't switch to %1$@-%2$@ because the pair is unavailable for exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeUnavailableSwitchText = Rswift.StringResource(key: "Exchange.UnavailableSwitch.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Cancel
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let cancel = Rswift.StringResource(key: "Cancel", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Cancel transaction
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionCancelTitle = Rswift.StringResource(key: "Transaction.Cancel.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: ChangeNOW will pick the best rate for you at the moment of the exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateDescription = Rswift.StringResource(key: "Exchange.ExpectedRate.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: ChangeNOW:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositTitleChangeNOW = Rswift.StringResource(key: "Transaction.Deposit.Title.ChangeNOW", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Congratulations! Exchange completed successfully. Can't wait to start a new one.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionRateUsTitle = Rswift.StringResource(key: "Transaction.RateUs.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Congratulations! Exchange completed successfully. Can't wait to start a new one.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusFinishedDescription = Rswift.StringResource(key: "Transaction.Status.Finished.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Contact support
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionSupportButton = Rswift.StringResource(key: "Transaction.Support.Button", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Copied
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let copied = Rswift.StringResource(key: "Copied", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Doesn't match any currencies or tickers that we support for exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyEmpty = Rswift.StringResource(key: "ChooseCurrency.Empty", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Done
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let done = Rswift.StringResource(key: "Done", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Error
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let error = Rswift.StringResource(key: "Error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExchange = Rswift.StringResource(key: "Exchange.Exchange", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Exchanging
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusExchanging = Rswift.StringResource(key: "Transaction.Status.Exchanging", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Failed
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusFailed = Rswift.StringResource(key: "Transaction.Status.Failed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Failed to validate data
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let currencyValidationRuleErrorRegexNotFound = Rswift.StringResource(key: "CurrencyValidationRule.Error.RegexNotFound", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Fiat currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyFiat = Rswift.StringResource(key: "ChooseCurrency.Fiat", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Finished
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusFinished = Rswift.StringResource(key: "Transaction.Status.Finished", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Get %1$@ from %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyGetSpecific = Rswift.StringResource(key: "ChooseCurrency.GetSpecific", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Go!
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStartNewAction = Rswift.StringResource(key: "Transaction.StartNew.Action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: I want to start a new exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStartNewFailure = Rswift.StringResource(key: "Transaction.StartNew.Failure", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Incorrect Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeIncorrectRecipientAddress = Rswift.StringResource(key: "Exchange.IncorrectRecipientAddress", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Incorrect or missing info
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeNoDataTitle = Rswift.StringResource(key: "Exchange.NoData.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Minimum amount is %1$@ %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeMinimumAmount = Rswift.StringResource(key: "Exchange.MinimumAmount", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Network fees and all other exchange expenses are included in the rate.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateFees = Rswift.StringResource(key: "Exchange.ExpectedRate.Fees", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: No
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let no = Rswift.StringResource(key: "No", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: No Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeNoAddressTitle = Rswift.StringResource(key: "Exchange.NoAddress.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Okay
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let ok = Rswift.StringResource(key: "Ok", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Oops! Please check your internet connection and pull to refresh
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let internetErrorRefresh = Rswift.StringResource(key: "InternetError.Refresh", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Other currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyOther = Rswift.StringResource(key: "ChooseCurrency.Other", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Pair %1$@ to %2$@ is currently not available for exchange. Try later.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeUnavailablePair = Rswift.StringResource(key: "Exchange.UnavailablePair", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Pair Not Available
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangePairNotAvailable = Rswift.StringResource(key: "Exchange.PairNotAvailable", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Please add the wallet address where you would like us to send your money.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeNoAddressText = Rswift.StringResource(key: "Exchange.NoAddress.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Please re-check the amount you want to exchange and the recipient address and try again.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeNoDataText = Rswift.StringResource(key: "Exchange.NoData.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Please scan the QR address of the wallet where you want to receive crypto
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let scannerDescription = Rswift.StringResource(key: "Scanner.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Please specify the amount of funds you would like to exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeNoAmountText = Rswift.StringResource(key: "Exchange.NoAmount.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Popular currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyPopular = Rswift.StringResource(key: "ChooseCurrency.Popular", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Rate us on the App store
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionRateUsButton = Rswift.StringResource(key: "Transaction.RateUs.Button", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Ready to start a new exchange?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStartNewSuccess = Rswift.StringResource(key: "Transaction.StartNew.Success", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Received:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionReceived = Rswift.StringResource(key: "Transaction.Received", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Refunded
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusRefunded = Rswift.StringResource(key: "Transaction.Status.Refunded", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Refunded:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionRefunded = Rswift.StringResource(key: "Transaction.Refunded", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Scanning not supported
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let scannerErrorTitle = Rswift.StringResource(key: "Scanner.ErrorTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Send deposit in %@ via:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositViaApps = Rswift.StringResource(key: "Transaction.Deposit.ViaApps", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Send money:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositMoney = Rswift.StringResource(key: "Transaction.Deposit.Money", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Share address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositShare = Rswift.StringResource(key: "Transaction.Deposit.Share", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Show QR code
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositShowQR = Rswift.StringResource(key: "Transaction.Deposit.ShowQR", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: So you get your crypto back. Now let's start a new exchange and bring it to the end.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusRefundedDescription = Rswift.StringResource(key: "Transaction.Status.Refunded.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Something went wrong with your transaction.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionSupportTitle = Rswift.StringResource(key: "Transaction.Support.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: The %@ address is not valid
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let currencyValidationRuleErrorInvalidAddress = Rswift.StringResource(key: "CurrencyValidationRule.Error.InvalidAddress", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: The %@ value is not valid
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let currencyValidationRuleErrorInvalidExtraId = Rswift.StringResource(key: "CurrencyValidationRule.Error.InvalidExtraId", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: The sooner you send a deposit, the higher chance of receiving the expected amount.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusDepositDescription = Rswift.StringResource(key: "Transaction.Status.Deposit.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: This is an Expected Rate
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateTitle = Rswift.StringResource(key: "Exchange.ExpectedRate.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: To Recipient %@ Address:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionRecipientAddress = Rswift.StringResource(key: "Transaction.RecipientAddress", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: To Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeRecipientAddress = Rswift.StringResource(key: "Exchange.RecipientAddress", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: To address:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositAddress = Rswift.StringResource(key: "Transaction.Deposit.Address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: To your %@ wallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeToSpecific = Rswift.StringResource(key: "Exchange.ToSpecific", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Transaction ID
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionId = Rswift.StringResource(key: "Transaction.Id", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Type in a currency or ticker
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencySearchPlaceholder = Rswift.StringResource(key: "ChooseCurrency.Search.Placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Use your wallet to send deposit to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositTitle = Rswift.StringResource(key: "Transaction.Deposit.Title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Waiting for network... Please check your internet connection
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let internetErrorWaiting = Rswift.StringResource(key: "InternetError.Waiting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: We are looking for the best way to exchange this amount and send you the money.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusExchangingDescription = Rswift.StringResource(key: "Transaction.Status.Exchanging.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: We are working on the problem. Contact us to get updates or provide any additional information to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionSupportText = Rswift.StringResource(key: "Transaction.Support.Text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: We guarantee no extra costs.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateNoExtraCosts = Rswift.StringResource(key: "Exchange.ExpectedRate.NoExtraCosts", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Wow! You have received more than expected. That's how good we are at trading.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionRateUsTitleMore = Rswift.StringResource(key: "Transaction.RateUs.TitleMore", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Wow! You have received more than expected. That's how good we are at trading.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionStatusFinishedMoreDescription = Rswift.StringResource(key: "Transaction.Status.FinishedMore.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Yes
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let yes = Rswift.StringResource(key: "Yes", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You get
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeGet = Rswift.StringResource(key: "Exchange.Get", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You get:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionYouGet = Rswift.StringResource(key: "Transaction.YouGet", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You need to set up a Mail application
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let errorMail = Rswift.StringResource(key: "Error.Mail", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You send
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeSend = Rswift.StringResource(key: "Exchange.Send", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You send:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionYouSend = Rswift.StringResource(key: "Transaction.YouSend", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: You sent:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionYouSent = Rswift.StringResource(key: "Transaction.YouSent", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Your device does not support scanning of QR codes. Please use a device with a camera.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let scannerErrorMessage = Rswift.StringResource(key: "Scanner.ErrorMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: best
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateDescriptionBest = Rswift.StringResource(key: "Exchange.ExpectedRate.Description.Best", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: from %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyFrom = Rswift.StringResource(key: "ChooseCurrency.From", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: guarantee
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateNoExtraCostsGuarantee = Rswift.StringResource(key: "Exchange.ExpectedRate.NoExtraCosts.Guarantee", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: included
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let exchangeExpectedRateFeesIncluded = Rswift.StringResource(key: "Exchange.ExpectedRate.Fees.Included", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: one tap
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let transactionDepositViaAppsOneTap = Rswift.StringResource(key: "Transaction.Deposit.ViaApps.OneTap", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let chooseCurrencyTo = Rswift.StringResource(key: "ChooseCurrency.To", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)
      /// en translation: Get Litecoin from 200+ crypto currencies Fast and secure exchanges No account needed
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static let buyViaChangeNowDescription = Rswift.StringResource(key: "BuyVia.ChangeNow.Description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["de", "ar", "zh-Hans", "ja", "en", "es", "da", "it", "ms", "sv", "ko", "zh-Hant", "ru", "fr", "id", "nl", "pt", "hi"], comment: nil)

      /// en translation: %1$@ to %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionTitle(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.Title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Title"
        }

        let format = NSLocalizedString("Transaction.Title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: %@ (optional)
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExtraId(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.ExtraId", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExtraId"
        }

        let format = NSLocalizedString("Exchange.ExtraId", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ Wallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func depositQRWallet(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("DepositQR.Wallet", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "DepositQR.Wallet"
        }

        let format = NSLocalizedString("DepositQR.Wallet", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ coin is not supported by TrustWallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositTrustWalletNotSupported(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.Deposit.TrustWallet.NotSupported", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.TrustWallet.NotSupported"
        }

        let format = NSLocalizedString("Transaction.Deposit.TrustWallet.NotSupported", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Add %@ Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeAddress(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.Address", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.Address"
        }

        let format = NSLocalizedString("Exchange.Address", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Are you sure to start a new transaction?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStartNewAlert(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.StartNew.Alert", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.StartNew.Alert"
        }

        return NSLocalizedString("Transaction.StartNew.Alert", bundle: bundle, comment: "")
      }

      /// en translation: Are you sure want to cancel this transaction and start a new one?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionCancelText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Cancel.Text", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Cancel.Text"
        }

        return NSLocalizedString("Transaction.Cancel.Text", bundle: bundle, comment: "")
      }

      /// en translation: Awaiting deposit
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusDeposit(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Deposit", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Deposit"
        }

        return NSLocalizedString("Transaction.Status.Deposit", bundle: bundle, comment: "")
      }

      /// en translation: Can't switch to %1$@-%2$@ because the pair is unavailable for exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeUnavailableSwitchText(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.UnavailableSwitch.Text", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.UnavailableSwitch.Text"
        }

        let format = NSLocalizedString("Exchange.UnavailableSwitch.Text", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Cancel
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func cancel(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Cancel", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Cancel"
        }

        return NSLocalizedString("Cancel", bundle: bundle, comment: "")
      }

      /// en translation: Cancel transaction
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionCancelTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Cancel.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Cancel.Title"
        }

        return NSLocalizedString("Transaction.Cancel.Title", bundle: bundle, comment: "")
      }

      /// en translation: ChangeNOW will pick the best rate for you at the moment of the exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.Description"
        }

        return NSLocalizedString("Exchange.ExpectedRate.Description", bundle: bundle, comment: "")
      }

      /// en translation: ChangeNOW:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositTitleChangeNOW(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.Title.ChangeNOW", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.Title.ChangeNOW"
        }

        return NSLocalizedString("Transaction.Deposit.Title.ChangeNOW", bundle: bundle, comment: "")
      }

      /// en translation: Congratulations! Exchange completed successfully. Can't wait to start a new one.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionRateUsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.RateUs.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.RateUs.Title"
        }

        return NSLocalizedString("Transaction.RateUs.Title", bundle: bundle, comment: "")
      }

      /// en translation: Congratulations! Exchange completed successfully. Can't wait to start a new one.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusFinishedDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Finished.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Finished.Description"
        }

        return NSLocalizedString("Transaction.Status.Finished.Description", bundle: bundle, comment: "")
      }

      /// en translation: Contact support
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionSupportButton(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Support.Button", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Support.Button"
        }

        return NSLocalizedString("Transaction.Support.Button", bundle: bundle, comment: "")
      }

      /// en translation: Copied
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func copied(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Copied", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Copied"
        }

        return NSLocalizedString("Copied", bundle: bundle, comment: "")
      }

      /// en translation: Doesn't match any currencies or tickers that we support for exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyEmpty(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ChooseCurrency.Empty", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.Empty"
        }

        return NSLocalizedString("ChooseCurrency.Empty", bundle: bundle, comment: "")
      }

      /// en translation: Done
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func done(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Done", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Done"
        }

        return NSLocalizedString("Done", bundle: bundle, comment: "")
      }

      /// en translation: Error
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func error(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Error"
        }

        return NSLocalizedString("Error", bundle: bundle, comment: "")
      }

      /// en translation: Exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExchange(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.Exchange", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.Exchange"
        }

        return NSLocalizedString("Exchange.Exchange", bundle: bundle, comment: "")
      }

      /// en translation: Exchanging
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusExchanging(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Exchanging", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Exchanging"
        }

        return NSLocalizedString("Transaction.Status.Exchanging", bundle: bundle, comment: "")
      }

      /// en translation: Failed
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusFailed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Failed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Failed"
        }

        return NSLocalizedString("Transaction.Status.Failed", bundle: bundle, comment: "")
      }

      /// en translation: Failed to validate data
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func currencyValidationRuleErrorRegexNotFound(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("CurrencyValidationRule.Error.RegexNotFound", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "CurrencyValidationRule.Error.RegexNotFound"
        }

        return NSLocalizedString("CurrencyValidationRule.Error.RegexNotFound", bundle: bundle, comment: "")
      }

      /// en translation: Fiat currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyFiat(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ChooseCurrency.Fiat", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.Fiat"
        }

        return NSLocalizedString("ChooseCurrency.Fiat", bundle: bundle, comment: "")
      }

      /// en translation: Finished
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusFinished(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Finished", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Finished"
        }

        return NSLocalizedString("Transaction.Status.Finished", bundle: bundle, comment: "")
      }

      /// en translation: Get %1$@ from %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyGetSpecific(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("ChooseCurrency.GetSpecific", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.GetSpecific"
        }

        let format = NSLocalizedString("ChooseCurrency.GetSpecific", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Go!
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStartNewAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.StartNew.Action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.StartNew.Action"
        }

        return NSLocalizedString("Transaction.StartNew.Action", bundle: bundle, comment: "")
      }

      /// en translation: I want to start a new exchange
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStartNewFailure(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.StartNew.Failure", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.StartNew.Failure"
        }

        return NSLocalizedString("Transaction.StartNew.Failure", bundle: bundle, comment: "")
      }

      /// en translation: Incorrect Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeIncorrectRecipientAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.IncorrectRecipientAddress", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.IncorrectRecipientAddress"
        }

        return NSLocalizedString("Exchange.IncorrectRecipientAddress", bundle: bundle, comment: "")
      }

      /// en translation: Incorrect or missing info
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeNoDataTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.NoData.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.NoData.Title"
        }

        return NSLocalizedString("Exchange.NoData.Title", bundle: bundle, comment: "")
      }

      /// en translation: Minimum amount is %1$@ %2$@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeMinimumAmount(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.MinimumAmount", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.MinimumAmount"
        }

        let format = NSLocalizedString("Exchange.MinimumAmount", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Network fees and all other exchange expenses are included in the rate.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateFees(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.Fees", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.Fees"
        }

        return NSLocalizedString("Exchange.ExpectedRate.Fees", bundle: bundle, comment: "")
      }

      /// en translation: No
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func no(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("No", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "No"
        }

        return NSLocalizedString("No", bundle: bundle, comment: "")
      }

      /// en translation: No Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeNoAddressTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.NoAddress.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.NoAddress.Title"
        }

        return NSLocalizedString("Exchange.NoAddress.Title", bundle: bundle, comment: "")
      }

      /// en translation: Okay
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func ok(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ok", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Ok"
        }

        return NSLocalizedString("Ok", bundle: bundle, comment: "")
      }

      /// en translation: Oops! Please check your internet connection and pull to refresh
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func internetErrorRefresh(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("InternetError.Refresh", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "InternetError.Refresh"
        }

        return NSLocalizedString("InternetError.Refresh", bundle: bundle, comment: "")
      }

      /// en translation: Other currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyOther(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ChooseCurrency.Other", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.Other"
        }

        return NSLocalizedString("ChooseCurrency.Other", bundle: bundle, comment: "")
      }

      /// en translation: Pair %1$@ to %2$@ is currently not available for exchange. Try later.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeUnavailablePair(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.UnavailablePair", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.UnavailablePair"
        }

        let format = NSLocalizedString("Exchange.UnavailablePair", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Pair Not Available
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangePairNotAvailable(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.PairNotAvailable", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.PairNotAvailable"
        }

        return NSLocalizedString("Exchange.PairNotAvailable", bundle: bundle, comment: "")
      }

      /// en translation: Please add the wallet address where you would like us to send your money.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeNoAddressText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.NoAddress.Text", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.NoAddress.Text"
        }

        return NSLocalizedString("Exchange.NoAddress.Text", bundle: bundle, comment: "")
      }

      /// en translation: Please re-check the amount you want to exchange and the recipient address and try again.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeNoDataText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.NoData.Text", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.NoData.Text"
        }

        return NSLocalizedString("Exchange.NoData.Text", bundle: bundle, comment: "")
      }

      /// en translation: Please scan the QR address of the wallet where you want to receive crypto
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func scannerDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Scanner.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Scanner.Description"
        }

        return NSLocalizedString("Scanner.Description", bundle: bundle, comment: "")
      }

      /// en translation: Please specify the amount of funds you would like to exchange.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeNoAmountText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.NoAmount.Text", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.NoAmount.Text"
        }

        return NSLocalizedString("Exchange.NoAmount.Text", bundle: bundle, comment: "")
      }

      /// en translation: Popular currencies
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyPopular(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ChooseCurrency.Popular", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.Popular"
        }

        return NSLocalizedString("ChooseCurrency.Popular", bundle: bundle, comment: "")
      }

      /// en translation: Rate us on the App store
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionRateUsButton(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.RateUs.Button", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.RateUs.Button"
        }

        return NSLocalizedString("Transaction.RateUs.Button", bundle: bundle, comment: "")
      }

      /// en translation: Ready to start a new exchange?
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStartNewSuccess(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.StartNew.Success", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.StartNew.Success"
        }

        return NSLocalizedString("Transaction.StartNew.Success", bundle: bundle, comment: "")
      }

      /// en translation: Received:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionReceived(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Received", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Received"
        }

        return NSLocalizedString("Transaction.Received", bundle: bundle, comment: "")
      }

      /// en translation: Refunded
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusRefunded(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Refunded", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Refunded"
        }

        return NSLocalizedString("Transaction.Status.Refunded", bundle: bundle, comment: "")
      }

      /// en translation: Refunded:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionRefunded(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Refunded", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Refunded"
        }

        return NSLocalizedString("Transaction.Refunded", bundle: bundle, comment: "")
      }

      /// en translation: Scanning not supported
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func scannerErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Scanner.ErrorTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Scanner.ErrorTitle"
        }

        return NSLocalizedString("Scanner.ErrorTitle", bundle: bundle, comment: "")
      }

      /// en translation: Send deposit in %@ via:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositViaApps(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.Deposit.ViaApps", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.ViaApps"
        }

        let format = NSLocalizedString("Transaction.Deposit.ViaApps", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Send money:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositMoney(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.Money", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.Money"
        }

        return NSLocalizedString("Transaction.Deposit.Money", bundle: bundle, comment: "")
      }

      /// en translation: Share address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositShare(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.Share", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.Share"
        }

        return NSLocalizedString("Transaction.Deposit.Share", bundle: bundle, comment: "")
      }

      /// en translation: Show QR code
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositShowQR(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.ShowQR", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.ShowQR"
        }

        return NSLocalizedString("Transaction.Deposit.ShowQR", bundle: bundle, comment: "")
      }

      /// en translation: So you get your crypto back. Now let's start a new exchange and bring it to the end.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusRefundedDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Refunded.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Refunded.Description"
        }

        return NSLocalizedString("Transaction.Status.Refunded.Description", bundle: bundle, comment: "")
      }

      /// en translation: Something went wrong with your transaction.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionSupportTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Support.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Support.Title"
        }

        return NSLocalizedString("Transaction.Support.Title", bundle: bundle, comment: "")
      }

      /// en translation: The %@ address is not valid
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func currencyValidationRuleErrorInvalidAddress(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("CurrencyValidationRule.Error.InvalidAddress", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "CurrencyValidationRule.Error.InvalidAddress"
        }

        let format = NSLocalizedString("CurrencyValidationRule.Error.InvalidAddress", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: The %@ value is not valid
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func currencyValidationRuleErrorInvalidExtraId(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("CurrencyValidationRule.Error.InvalidExtraId", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "CurrencyValidationRule.Error.InvalidExtraId"
        }

        let format = NSLocalizedString("CurrencyValidationRule.Error.InvalidExtraId", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: The sooner you send a deposit, the higher chance of receiving the expected amount.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusDepositDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Deposit.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Deposit.Description"
        }

        return NSLocalizedString("Transaction.Status.Deposit.Description", bundle: bundle, comment: "")
      }

      /// en translation: This is an Expected Rate
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.Title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.Title"
        }

        return NSLocalizedString("Exchange.ExpectedRate.Title", bundle: bundle, comment: "")
      }

      /// en translation: To Recipient %@ Address:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionRecipientAddress(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.RecipientAddress", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.RecipientAddress"
        }

        let format = NSLocalizedString("Transaction.RecipientAddress", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: To Recipient Address
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeRecipientAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.RecipientAddress", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.RecipientAddress"
        }

        return NSLocalizedString("Exchange.RecipientAddress", bundle: bundle, comment: "")
      }

      /// en translation: To address:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.Address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.Address"
        }

        return NSLocalizedString("Transaction.Deposit.Address", bundle: bundle, comment: "")
      }

      /// en translation: To your %@ wallet
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeToSpecific(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Exchange.ToSpecific", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ToSpecific"
        }

        let format = NSLocalizedString("Exchange.ToSpecific", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Transaction ID
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionId(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Id", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Id"
        }

        return NSLocalizedString("Transaction.Id", bundle: bundle, comment: "")
      }

      /// en translation: Type in a currency or ticker
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencySearchPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ChooseCurrency.Search.Placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.Search.Placeholder"
        }

        return NSLocalizedString("ChooseCurrency.Search.Placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Use your wallet to send deposit to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.Deposit.Title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.Title"
        }

        let format = NSLocalizedString("Transaction.Deposit.Title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Waiting for network... Please check your internet connection
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func internetErrorWaiting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("InternetError.Waiting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "InternetError.Waiting"
        }

        return NSLocalizedString("InternetError.Waiting", bundle: bundle, comment: "")
      }

      /// en translation: We are looking for the best way to exchange this amount and send you the money.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusExchangingDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.Exchanging.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.Exchanging.Description"
        }

        return NSLocalizedString("Transaction.Status.Exchanging.Description", bundle: bundle, comment: "")
      }

      /// en translation: We are working on the problem. Contact us to get updates or provide any additional information to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionSupportText(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Transaction.Support.Text", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Support.Text"
        }

        let format = NSLocalizedString("Transaction.Support.Text", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: We guarantee no extra costs.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateNoExtraCosts(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.NoExtraCosts", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.NoExtraCosts"
        }

        return NSLocalizedString("Exchange.ExpectedRate.NoExtraCosts", bundle: bundle, comment: "")
      }

      /// en translation: Wow! You have received more than expected. That's how good we are at trading.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionRateUsTitleMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.RateUs.TitleMore", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.RateUs.TitleMore"
        }

        return NSLocalizedString("Transaction.RateUs.TitleMore", bundle: bundle, comment: "")
      }

      /// en translation: Wow! You have received more than expected. That's how good we are at trading.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionStatusFinishedMoreDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Status.FinishedMore.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Status.FinishedMore.Description"
        }

        return NSLocalizedString("Transaction.Status.FinishedMore.Description", bundle: bundle, comment: "")
      }

      /// en translation: Yes
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func yes(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Yes", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Yes"
        }

        return NSLocalizedString("Yes", bundle: bundle, comment: "")
      }

      /// en translation: You get
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeGet(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.Get", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.Get"
        }

        return NSLocalizedString("Exchange.Get", bundle: bundle, comment: "")
      }

      /// en translation: You get:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionYouGet(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.YouGet", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.YouGet"
        }

        return NSLocalizedString("Transaction.YouGet", bundle: bundle, comment: "")
      }

      /// en translation: You need to set up a Mail application
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func errorMail(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Error.Mail", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Error.Mail"
        }

        return NSLocalizedString("Error.Mail", bundle: bundle, comment: "")
      }

      /// en translation: You send
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeSend(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.Send", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.Send"
        }

        return NSLocalizedString("Exchange.Send", bundle: bundle, comment: "")
      }

      /// en translation: You send:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionYouSend(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.YouSend", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.YouSend"
        }

        return NSLocalizedString("Transaction.YouSend", bundle: bundle, comment: "")
      }

      /// en translation: You sent:
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionYouSent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.YouSent", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.YouSent"
        }

        return NSLocalizedString("Transaction.YouSent", bundle: bundle, comment: "")
      }

      /// en translation: Your device does not support scanning of QR codes. Please use a device with a camera.
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func scannerErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Scanner.ErrorMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Scanner.ErrorMessage"
        }

        return NSLocalizedString("Scanner.ErrorMessage", bundle: bundle, comment: "")
      }

      /// en translation: best
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateDescriptionBest(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.Description.Best", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.Description.Best"
        }

        return NSLocalizedString("Exchange.ExpectedRate.Description.Best", bundle: bundle, comment: "")
      }

      /// en translation: from %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyFrom(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("ChooseCurrency.From", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.From"
        }

        let format = NSLocalizedString("ChooseCurrency.From", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: guarantee
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateNoExtraCostsGuarantee(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.NoExtraCosts.Guarantee", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.NoExtraCosts.Guarantee"
        }

        return NSLocalizedString("Exchange.ExpectedRate.NoExtraCosts.Guarantee", bundle: bundle, comment: "")
      }

      /// en translation: included
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func exchangeExpectedRateFeesIncluded(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Exchange.ExpectedRate.Fees.Included", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Exchange.ExpectedRate.Fees.Included"
        }

        return NSLocalizedString("Exchange.ExpectedRate.Fees.Included", bundle: bundle, comment: "")
      }

      /// en translation: one tap
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func transactionDepositViaAppsOneTap(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Transaction.Deposit.ViaApps.OneTap", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Transaction.Deposit.ViaApps.OneTap"
        }

        return NSLocalizedString("Transaction.Deposit.ViaApps.OneTap", bundle: bundle, comment: "")
      }

      /// en translation: to %@
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func chooseCurrencyTo(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("ChooseCurrency.To", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ChooseCurrency.To"
        }

        let format = NSLocalizedString("ChooseCurrency.To", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Get Litecoin from 200+ crypto currencies Fast and secure exchanges No account needed
      ///
      /// Locales: de, ar, zh-Hans, ja, en, es, da, it, ms, sv, ko, zh-Hant, ru, fr, id, nl, pt, hi
      static func buyViaChangeNowDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("BuyVia.ChangeNow.Description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "BuyVia.ChangeNow.Description"
        }

        return NSLocalizedString("BuyVia.ChangeNow.Description", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      // There are no resources to validate
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R {
  fileprivate init() {}
}
